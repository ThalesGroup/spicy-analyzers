module Zeek_TLS;

import TLS from protocols;
import zeek;

public function convert_server_names(snl: TLS::ServerNameList) : vector<bytes> {
  local out: vector<bytes>;

  for ( i in snl.server_name_list )
    out.push_back(i.host_name);

  return out;
}

public function convert_signature_algorithms(sa: TLS::SignatureAlgorithms) : vector<tuple<HashAlgorithm: uint8, SignatureAlgorithm: uint8>> {
  local out: vector<tuple<uint8, uint8>>;
  for ( i in sa.supported_signature_algorithms )
    out.push_back(tuple(i.hash, i.signature));

  return out;
}

public function convert_clienthellokeyshare(ks: TLS::ClientHelloKeyShare) : vector<uint16> {
  local out: vector<uint16>;

  for ( i in ks.keyshares )
    out.push_back(i.namedgroup);

  return out;
}

public function convert_binders(bi: TLS::PSKBindersList) : vector<bytes> {
  local out: vector<bytes>;

  for ( i in bi.binders )
    out.push_back(i.binder);

  return out;
}

public function convert_identities(id: TLS::PSKIdentitiesList) : vector<tuple<identity: bytes, obfuscated_ticket_age: uint32>> {
  local out: vector<tuple<bytes, uint32>>;
  for ( i in id.identities )
    out.push_back(tuple(i.identity, i.obfuscated_ticket_age));
  return out;
}

public function convert_protocol_name_list(pns: TLS::ProtocolNameList) : vector<bytes> {
  local out: vector<bytes>;
  for ( i in pns.protocol_name_list )
    out.push_back(i.name);
  return out;
}

on TLS::ClientHello::%done {
  zeek::confirm_protocol();
}

on TLS::ClientHello::%error {
  zeek::reject_protocol("error while parsing TLS client hello");
}

on TLS::ServerHello::%done {
  zeek::confirm_protocol();
}

on TLS::ServerHello::%error {
  zeek::reject_protocol("error while parsing TLS server hello");
}

on TLS::Certificate::%done {
  local first: bool = True;
  for ( i in self.certificate_list )
    {
    if ( first )
			zeek::file_begin("application/x-x509-user-cert");
		else
			zeek::file_begin("application/x-x509-ca-cert");
		zeek::file_data_in(i.cert);
    zeek::file_end();
    first = False;
    }
}
